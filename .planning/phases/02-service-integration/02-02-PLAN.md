---
phase: 02-service-integration
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - lobster/core/vector/service.py
  - lobster/core/vector/__init__.py
  - tests/unit/core/vector/test_vector_search_service.py
  - tests/unit/core/vector/test_config.py
autonomous: true
requirements: [SRCH-01, SRCH-02, SRCH-03, SRCH-04, SCHM-03, TEST-04, TEST-05, TEST-07]

must_haves:
  truths:
    - "VectorSearchService.match_ontology('heart attack', 'disease') returns List[OntologyMatch] with MONDO IDs"
    - "Alias resolution works: 'disease' resolves to mondo collection, 'tissue' to uberon, 'cell_type' to cell_ontology"
    - "Oversampling requests k*4 from backend, returns top k after truncation"
    - "Unknown ontology name raises ValueError with available options"
    - "OntologyMatch objects have term, ontology_id, score, metadata, distance_metric fields"
    - "Empty backend results return empty list without error"
  artifacts:
    - path: "lobster/core/vector/service.py"
      provides: "match_ontology() method and ONTOLOGY_COLLECTIONS constant"
      contains: "match_ontology"
    - path: "tests/unit/core/vector/test_vector_search_service.py"
      provides: "Tests for match_ontology orchestration"
      contains: "TestMatchOntology"
  key_links:
    - from: "lobster/core/vector/service.py"
      to: "lobster/core/schemas/search.py"
      via: "OntologyMatch Pydantic model import"
      pattern: "from lobster\\.core\\.schemas\\.search import OntologyMatch"
    - from: "lobster/core/vector/service.py"
      to: "ONTOLOGY_COLLECTIONS"
      via: "alias resolution in match_ontology"
      pattern: "ONTOLOGY_COLLECTIONS\\.get"
---

<objective>
Add match_ontology() method to VectorSearchService with ONTOLOGY_COLLECTIONS alias resolution, oversampling, and typed OntologyMatch returns. TDD approach: write failing tests first, then implement.

Purpose: match_ontology() is the domain-aware API that agents and DiseaseOntologyService (Plan 03) call to semantically match biomedical terms to ontology concepts. It wraps the Phase 1 query() primitive with alias resolution, oversampling for future reranking, and typed Pydantic results.
Output: Extended VectorSearchService with match_ontology(), ONTOLOGY_COLLECTIONS constant, comprehensive tests
</objective>

<execution_context>
@/Users/tyo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tyo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-03-SUMMARY.md
@.planning/phases/02-service-integration/02-RESEARCH.md
@lobster/core/vector/service.py
@lobster/core/schemas/search.py
@tests/unit/core/vector/test_vector_search_service.py
</context>

<feature>
  <name>match_ontology() — domain-aware ontology matching API</name>
  <files>lobster/core/vector/service.py, tests/unit/core/vector/test_vector_search_service.py, tests/unit/core/vector/test_config.py, lobster/core/vector/__init__.py</files>
  <behavior>
    Expected behavior in testable terms:

    1. ONTOLOGY_COLLECTIONS constant maps aliases to versioned collection names:
       - "mondo" -> "mondo_v2024_01", "disease" -> "mondo_v2024_01"
       - "uberon" -> "uberon_v2024_01", "tissue" -> "uberon_v2024_01"
       - "cell_ontology" -> "cell_ontology_v2024_01", "cell_type" -> "cell_ontology_v2024_01"

    2. match_ontology(term, ontology, k=5) -> list[OntologyMatch]:
       - Resolves ontology name via ONTOLOGY_COLLECTIONS
       - Calls self.query(term, resolved_collection, top_k=k*4) for oversampling
       - Converts raw dicts to OntologyMatch Pydantic objects
       - Returns first k results (truncated from oversampled set)
       - Raises ValueError for unknown ontology names

    Test cases:
       match_ontology("heart attack", "disease", k=3) -> list of 3 OntologyMatch with MONDO IDs
       match_ontology("lung", "tissue") -> list of OntologyMatch with UBERON IDs
       match_ontology("T cell", "cell_type") -> list of OntologyMatch with CL IDs
       match_ontology("test", "invalid") -> raises ValueError
       match_ontology("test", "mondo", k=3) with empty backend -> returns []
       match_ontology("test", "mondo", k=3) -> backend receives top_k=12 (3*4 oversampling)

    3. SCHM-03 compatibility: OntologyMatch fields can be mapped to DiseaseMatch fields:
       - ontology_id -> disease_id
       - term -> name
       - score -> confidence
       Verified via unit test constructing both and comparing field values.

    4. TEST-05: ONTOLOGY_COLLECTIONS has exactly 6 entries (3 primary + 3 aliases)

    5. TEST-07: Integration test (skipif no chromadb) creates a small test collection with 10 terms,
       embeds them, adds to ChromaDB, queries match_ontology(), verifies OntologyMatch results with real scores.
  </behavior>
  <implementation>
    RED phase — Write failing tests in test_vector_search_service.py:

    Add new test class `TestMatchOntology` with tests for:
    - test_match_ontology_returns_ontology_match_list (SRCH-01, SRCH-04)
    - test_match_ontology_alias_resolution_disease (SRCH-03)
    - test_match_ontology_alias_resolution_tissue (SRCH-03)
    - test_match_ontology_alias_resolution_cell_type (SRCH-03)
    - test_match_ontology_oversampling_k_times_4 (SRCH-02)
    - test_match_ontology_truncates_to_k (SRCH-02)
    - test_match_ontology_unknown_ontology_raises_value_error (SRCH-01)
    - test_match_ontology_empty_results (SRCH-04)

    Add new test class `TestOntologyMatchDiseaseMatchCompat` for SCHM-03:
    - test_ontology_match_to_disease_match_field_mapping

    Add to test_config.py:
    - test_ontology_collections_has_six_entries (TEST-05)
    - test_ontology_collections_aliases_resolve_correctly (TEST-05)

    Add test class `TestMatchOntologyIntegration` with @pytest.mark.skipif for TEST-07:
    - test_full_pipeline_with_real_chromadb (skip if chromadb not installed)

    GREEN phase — Implement in service.py:

    1. Add ONTOLOGY_COLLECTIONS dict constant at module level (above VectorSearchService class)
    2. Add match_ontology() method to VectorSearchService:
       - Resolve ontology alias via ONTOLOGY_COLLECTIONS.get()
       - Raise ValueError if not found
       - Call self.query(term, collection, top_k=k*4)
       - Convert each raw dict to OntologyMatch(...) Pydantic model
       - Return results[:k] truncated list
    3. Update __init__.py to add ONTOLOGY_COLLECTIONS to __all__ and __getattr__
  </implementation>
</feature>

<verification>
1. RED: `python -m pytest tests/unit/core/vector/test_vector_search_service.py::TestMatchOntology -v` — all tests FAIL (method doesn't exist yet)
2. GREEN: `python -m pytest tests/unit/core/vector/test_vector_search_service.py -v` — ALL tests pass (existing + new)
3. `python -m pytest tests/unit/core/vector/test_config.py -v` — config tests pass including new ONTOLOGY_COLLECTIONS tests
4. `python -c "from lobster.core.vector import ONTOLOGY_COLLECTIONS; assert len(ONTOLOGY_COLLECTIONS) == 6"` passes
5. Existing 39 tests from Phase 1 still pass (no regressions)
</verification>

<success_criteria>
- match_ontology() returns List[OntologyMatch] with typed Pydantic objects
- ONTOLOGY_COLLECTIONS has 6 entries (3 primary + 3 aliases)
- Oversampling: backend receives k*4, results truncated to k
- ValueError raised for unknown ontology names
- OntologyMatch fields are compatible with DiseaseMatch for Phase 2 conversion (SCHM-03)
- All existing Phase 1 tests still pass
- Integration test with real ChromaDB (skipif) validates full pipeline
</success_criteria>

<output>
After completion, create `.planning/phases/02-service-integration/02-02-SUMMARY.md`
</output>
