---
phase: 04-ms-proteomics-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/lobster-proteomics/lobster/services/quality/proteomics_preprocessing_service.py
autonomous: true
requirements:
  - MSP-02
  - MSP-04
  - MSP-05

must_haves:
  truths:
    - "import_ptm_site_data method parses MaxQuant PTM site files and returns AnnData with site-level quantification"
    - "summarize_peptide_to_protein method rolls up peptide-level AnnData to protein-level using median or sum"
    - "normalize_ptm_to_protein method normalizes PTM site abundances against protein-level abundances"
  artifacts:
    - path: "packages/lobster-proteomics/lobster/services/quality/proteomics_preprocessing_service.py"
      provides: "3 new service methods: import_ptm_site_data, summarize_peptide_to_protein, normalize_ptm_to_protein"
      contains: "def import_ptm_site_data"
  key_links:
    - from: "proteomics_preprocessing_service.py import_ptm_site_data"
      to: "AnalysisStep IR"
      via: "Returns 3-tuple (AnnData, Dict, AnalysisStep)"
      pattern: "return.*adata.*stats.*ir"
    - from: "proteomics_preprocessing_service.py normalize_ptm_to_protein"
      to: "Two AnnData inputs (PTM + protein)"
      via: "Maps PTM sites to proteins via gene symbol extraction from site IDs"
      pattern: "ptm_adata.*protein_adata"
---

<objective>
Add 3 new service methods to ProteomicsPreprocessingService: PTM site import, peptide-to-protein summarization, and PTM-to-protein normalization. These are the service-layer foundations that Plan 02 tools will wrap.

Purpose: Creates the computational logic needed for new proteomics tools. All methods follow the 3-tuple return pattern and are stateless.
Output: 3 new methods on ProteomicsPreprocessingService
</objective>

<execution_context>
@/Users/tyo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tyo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-ms-proteomics-core/04-RESEARCH.md
@packages/lobster-proteomics/lobster/services/quality/proteomics_preprocessing_service.py
@lobster/services/data_access/proteomics_parsers/base_parser.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add import_ptm_site_data method to ProteomicsPreprocessingService</name>
  <files>packages/lobster-proteomics/lobster/services/quality/proteomics_preprocessing_service.py</files>
  <action>
Add a new method `import_ptm_site_data` to ProteomicsPreprocessingService. This method parses MaxQuant-style PTM site files (e.g., Phospho(STY)Sites.txt, Acetyl(K)Sites.txt, GlyGly(K)Sites.txt) into AnnData objects.

Add any needed imports at the top of the file: `from pathlib import Path`.

```python
def import_ptm_site_data(
    self,
    file_path: str,
    ptm_type: str = "phospho",
    localization_threshold: float = 0.75,
    filter_contaminants: bool = True,
    filter_reverse: bool = True,
    intensity_type: str = "auto",
) -> Tuple[anndata.AnnData, Dict[str, Any], AnalysisStep]:
    """
    Parse PTM site-level quantification data into AnnData.

    Reads tab-delimited MaxQuant site-level output files and constructs
    site-level AnnData where var_names are site IDs (gene_residuePosition format).

    Args:
        file_path: Path to PTM site file (tab-delimited)
        ptm_type: Type of PTM ("phospho", "acetyl", "ubiquitin")
        localization_threshold: Minimum localization probability for class I sites (default 0.75)
        filter_contaminants: Remove contaminant proteins
        filter_reverse: Remove reverse database hits
        intensity_type: "auto" detects LFQ/Intensity columns, or specify "lfq", "intensity"

    Returns:
        Tuple of (AnnData, stats_dict, AnalysisStep)
    """
```

Implementation details:
1. Read the file with `pd.read_csv(file_path, sep='\t', low_memory=False)`
2. Identify key columns:
   - Localization probability: look for column containing "Localization prob" or "localization_probability"
   - Gene names: "Gene names" or "Gene.names" or "Proteins"
   - Position: "Position" or "Positions within proteins"
   - Amino acid: "Amino acid" or "Amino.acid"
   - Contaminant: "Potential contaminant" or "Contaminant" (values "+")
   - Reverse: "Reverse" (values "+")
   - Multiplicity: "Multiplicity"
3. Filter by localization probability >= localization_threshold
4. Filter contaminants and reverse if flags are True
5. Auto-detect intensity columns: look for columns matching `^Intensity\s+` or `^LFQ intensity\s+` pattern. If intensity_type="auto", prefer LFQ if available, else raw Intensity. Extract sample names from column headers.
6. Construct site IDs: `{gene}_{amino_acid}{position}`. For multiply phosphorylated sites (multiplicity > 1), append `_m{multiplicity}`. Handle missing gene names by using protein ID.
7. Build AnnData:
   - X: intensity matrix (samples x sites), transpose if needed since MaxQuant outputs sites as rows
   - var: site metadata (gene, position, amino_acid, localization_prob, multiplicity, ptm_type)
   - obs: sample names from intensity column headers
   - uns: {"ptm_type": ptm_type, "localization_threshold": localization_threshold, "source_file": Path(file_path).name}
8. Replace 0 values with NaN (MaxQuant convention: 0 = undetected)
9. Create AnalysisStep IR with appropriate code_template for reproducibility
10. Return (adata, stats_dict, ir) where stats_dict includes: n_sites_total, n_sites_after_filter, n_samples, n_contaminants_removed, n_reverse_removed, missing_percentage, ptm_type
  </action>
  <verify>
1. `grep -c "def import_ptm_site_data" packages/lobster-proteomics/lobster/services/quality/proteomics_preprocessing_service.py` -- should be 1
2. `grep "ptm_type.*phospho\|localization_threshold" packages/lobster-proteomics/lobster/services/quality/proteomics_preprocessing_service.py` -- should find parameter defaults
3. `grep "AnalysisStep" packages/lobster-proteomics/lobster/services/quality/proteomics_preprocessing_service.py | grep -c "import_ptm"` -- should find IR creation
  </verify>
  <done>import_ptm_site_data method parses MaxQuant PTM site files, filters by localization probability, constructs gene_residuePosition site IDs, returns 3-tuple (AnnData, stats, AnalysisStep)</done>
</task>

<task type="auto">
  <name>Task 2: Add summarize_peptide_to_protein and normalize_ptm_to_protein methods</name>
  <files>packages/lobster-proteomics/lobster/services/quality/proteomics_preprocessing_service.py</files>
  <action>
Add 2 new methods to ProteomicsPreprocessingService.

**1. `summarize_peptide_to_protein` method (MSP-04):**

```python
def summarize_peptide_to_protein(
    self,
    adata: anndata.AnnData,
    method: str = "median",
    protein_column: str = "protein_id",
) -> Tuple[anndata.AnnData, Dict[str, Any], AnalysisStep]:
    """
    Roll up peptide/PSM-level quantification to protein-level.

    Required for TMT workflows where reporter ion intensities are at PSM level.
    Groups peptides by protein and aggregates using specified method.

    Args:
        adata: Peptide-level AnnData (obs=samples, var=peptides)
        method: Aggregation method ("median", "sum")
        protein_column: Column in var containing protein identifiers

    Returns:
        Tuple of (protein-level AnnData, stats_dict, AnalysisStep)
    """
```

Implementation:
1. Validate that `protein_column` exists in adata.var
2. Get the intensity matrix X (handle sparse -> dense)
3. Create a DataFrame with peptide intensities and protein mapping
4. Group by protein: for "median" use `groupby(protein_column).median()`, for "sum" use `.sum()`
5. Build new AnnData: obs stays identical (same samples), var is protein-level (new var_names = unique protein IDs)
6. Compute stats: n_peptides_input, n_proteins_output, median_peptides_per_protein, method_used
7. Create AnalysisStep IR
8. Return 3-tuple

Key constraint: obs (sample metadata) MUST be preserved exactly. Only X and var change during rollup.

**2. `normalize_ptm_to_protein` method (MSP-05):**

```python
def normalize_ptm_to_protein(
    self,
    ptm_adata: anndata.AnnData,
    protein_adata: anndata.AnnData,
    method: str = "ratio",
) -> Tuple[anndata.AnnData, Dict[str, Any], AnalysisStep]:
    """
    Normalize PTM site abundances against total protein levels.

    Separates true PTM regulation from protein abundance changes.
    Sites without a matching protein are kept with NaN normalization.

    Args:
        ptm_adata: PTM site-level AnnData (var_names are site IDs like EGFR_Y1068)
        protein_adata: Protein-level AnnData (var_names are protein/gene IDs)
        method: "ratio" (log subtraction) or "regression" (residuals)

    Returns:
        Tuple of (normalized PTM AnnData, stats_dict, AnalysisStep)
    """
```

Implementation:
1. Extract gene symbols from PTM site IDs: split on "_", take first part (e.g., "EGFR" from "EGFR_Y1068")
2. Find matching proteins in protein_adata.var_names for each PTM site's gene
3. For "ratio" method: normalized_ptm[i,j] = ptm_intensity[i,j] - protein_intensity[i, matching_protein_j] (log scale subtraction = ratio in linear scale)
4. For "regression" method: For each site, fit ptm ~ protein using scipy.stats.linregress, take residuals as normalized values
5. Build output AnnData: same shape as ptm_adata, X is normalized values, copy var and obs from ptm_adata
6. Add var column "matched_protein" indicating which protein was used for normalization
7. Add var column "normalization_applied" (True/False) for sites with/without match
8. Store method in uns: uns["ptm_normalization_method"] = method
9. Compute stats: n_sites_matched, n_sites_unmatched, matching_rate, method
10. Create AnalysisStep IR
11. Return 3-tuple

For both methods, follow the existing service pattern in the file (look at how correct_batch_effects, impute_missing_values, etc. are structured with try/except, logging, and IR creation).
  </action>
  <verify>
1. `grep -c "def summarize_peptide_to_protein\|def normalize_ptm_to_protein" packages/lobster-proteomics/lobster/services/quality/proteomics_preprocessing_service.py` -- should be 2
2. `grep "protein_column.*protein_id" packages/lobster-proteomics/lobster/services/quality/proteomics_preprocessing_service.py` -- should find summarize method parameter
3. `grep "ptm_adata.*protein_adata" packages/lobster-proteomics/lobster/services/quality/proteomics_preprocessing_service.py` -- should find normalize method
4. `grep "AnalysisStep" packages/lobster-proteomics/lobster/services/quality/proteomics_preprocessing_service.py` -- should find IR creation for both methods
  </verify>
  <done>summarize_peptide_to_protein rolls up peptide-level to protein-level preserving obs metadata; normalize_ptm_to_protein subtracts protein abundance from PTM intensity (log-scale) or uses regression residuals; both return 3-tuple with IR</done>
</task>

</tasks>

<verification>
1. All 3 requirements addressed: MSP-02 (PTM import service), MSP-04 (peptide-to-protein), MSP-05 (PTM normalization)
2. All 3 methods return proper 3-tuple (AnnData, Dict, AnalysisStep)
3. All methods are stateless (no data_manager dependency -- pure service methods)
4. import_ptm_site_data handles localization filtering, contaminant removal, proper site ID construction
5. summarize_peptide_to_protein preserves obs metadata through rollup
6. normalize_ptm_to_protein handles unmatched sites gracefully (NaN, not error)
</verification>

<success_criteria>
- import_ptm_site_data reads MaxQuant PTM files, filters by localization probability >= 0.75, produces AnnData with site IDs as var_names
- summarize_peptide_to_protein aggregates peptide AnnData to protein AnnData using median or sum, preserving obs
- normalize_ptm_to_protein subtracts protein abundance from PTM intensity or computes regression residuals
- All 3 methods have AnalysisStep IR for provenance tracking
- No pyproject.toml changes (all dependencies already present)
</success_criteria>

<output>
After completion, create `.planning/phases/04-ms-proteomics-core/04-01-SUMMARY.md`
</output>
