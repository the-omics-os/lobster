---
phase: 04-performance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lobster/core/vector/rerankers/__init__.py
  - lobster/core/vector/rerankers/base.py
  - lobster/core/vector/rerankers/cross_encoder_reranker.py
  - lobster/core/vector/rerankers/cohere_reranker.py
  - lobster/core/vector/config.py
  - lobster/core/vector/service.py
  - lobster/core/vector/__init__.py
autonomous: true
requirements:
  - RANK-01
  - RANK-02
  - RANK-03

must_haves:
  truths:
    - "match_ontology() reranks oversampled candidates when reranker is configured"
    - "Reranking can be disabled via config (reranker=none) without breaking search"
    - "CrossEncoderReranker loads model lazily on first rerank() call"
    - "CohereReranker returns original order when API key is missing (logs warning)"
    - "Reranker scores are normalized to [0.0, 1.0] for OntologyMatch compatibility"
  artifacts:
    - path: "lobster/core/vector/rerankers/base.py"
      provides: "BaseReranker ABC with rerank(query, documents, top_k) contract"
      contains: "class BaseReranker"
    - path: "lobster/core/vector/rerankers/cross_encoder_reranker.py"
      provides: "CrossEncoder reranker with lazy model loading"
      contains: "class CrossEncoderReranker"
    - path: "lobster/core/vector/rerankers/cohere_reranker.py"
      provides: "Cohere API reranker with graceful degradation"
      contains: "class CohereReranker"
    - path: "lobster/core/vector/config.py"
      provides: "create_reranker() factory and reranker field on VectorSearchConfig"
      contains: "create_reranker"
    - path: "lobster/core/vector/service.py"
      provides: "Reranking step between search and truncation in match_ontology()"
      contains: "_rerank"
  key_links:
    - from: "lobster/core/vector/service.py"
      to: "lobster/core/vector/rerankers/base.py"
      via: "reranker.rerank() call in match_ontology()"
      pattern: "reranker\\.rerank\\("
    - from: "lobster/core/vector/config.py"
      to: "lobster/core/vector/rerankers/cross_encoder_reranker.py"
      via: "lazy import in create_reranker()"
      pattern: "from lobster\\.core\\.vector\\.rerankers\\.cross_encoder_reranker"
    - from: "lobster/core/vector/config.py"
      to: "lobster/core/vector/rerankers/cohere_reranker.py"
      via: "lazy import in create_reranker()"
      pattern: "from lobster\\.core\\.vector\\.rerankers\\.cohere_reranker"
    - from: "lobster/core/vector/service.py"
      to: "lobster/core/vector/config.py"
      via: "config.create_reranker() called from _get_reranker()"
      pattern: "_config\\.create_reranker\\("
---

<objective>
Build the reranker infrastructure for two-stage retrieval: BaseReranker ABC, CrossEncoderReranker (sentence-transformers), CohereReranker (with graceful degradation), config factory, and service integration.

Purpose: Adds precision-boosting reranking to the vector search pipeline. Cross-encoder reranking typically improves NDCG by 10-15% by scoring (query, document) pairs through a full transformer pass rather than relying solely on bi-encoder cosine similarity.

Output: Complete reranker module wired into VectorSearchService.match_ontology(), controllable via config/env var, with no regressions when reranking is disabled.
</objective>

<execution_context>
@/Users/tyo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tyo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-performance/04-RESEARCH.md

@lobster/core/vector/service.py
@lobster/core/vector/config.py
@lobster/core/vector/__init__.py
@lobster/core/vector/embeddings/base.py
@lobster/core/vector/embeddings/sapbert.py
@lobster/core/schemas/search.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: BaseReranker ABC + CrossEncoderReranker + CohereReranker implementations</name>
  <files>
    lobster/core/vector/rerankers/__init__.py
    lobster/core/vector/rerankers/base.py
    lobster/core/vector/rerankers/cross_encoder_reranker.py
    lobster/core/vector/rerankers/cohere_reranker.py
  </files>
  <action>
Create the `lobster/core/vector/rerankers/` directory with 4 files:

**base.py** -- BaseReranker ABC following the exact pattern of BaseEmbedder in `lobster/core/vector/embeddings/base.py`:
- ABC with `rerank(self, query: str, documents: list[str], top_k: int | None = None) -> list[dict[str, Any]]` abstract method
- Return format: list of dicts with keys `corpus_id` (int, original index), `score` (float, higher=better), `text` (str, document text)
- Concrete `name` property returning class name (same as BaseEmbedder)
- Add a module-level `normalize_scores()` helper function that applies min-max normalization to a list of reranker result dicts, mapping scores to [0.0, 1.0]. If all scores equal, set all to 1.0. Round to 4 decimal places. This function is used by service.py after reranking.

**cross_encoder_reranker.py** -- CrossEncoderReranker (RANK-01):
- Lazy model loading following SapBERTEmbedder pattern: `_model = None` in `__init__`, `_load_model()` does the actual import+load
- Import guard: `from sentence_transformers import CrossEncoder` inside `_load_model()` with ImportError -> helpful message ("pip install 'lobster-ai[vector-search]'")
- Model: `cross-encoder/ms-marco-MiniLM-L-6-v2` as a module-level `MODEL_NAME` constant
- `rerank()`: calls `_load_model()`, then `self._model.rank(query, documents, top_k=top_k, return_documents=True)`
- Convert rank() output to standard format: `[{"corpus_id": r["corpus_id"], "score": float(r["score"]), "text": r["text"]}]`
- Edge case guard: if `len(documents) <= 1`, return early without loading model (single doc gets score=1.0, empty list returns [])
- Standard logging via `logging.getLogger(__name__)`

**cohere_reranker.py** -- CohereReranker (RANK-02):
- Graceful degradation: if no `COHERE_API_KEY` or `CO_API_KEY` env var, log warning and return original order with descending synthetic scores
- `_client = None`, `_available = None` in __init__. `_init_client()` checks env var, tries `import cohere`, creates `cohere.ClientV2(api_key=...)`, returns bool
- `_available` flag: `None` = not checked, `True` = ready, `False` = degraded. Only check once.
- Model: `rerank-v4.0-pro` as class constant `MODEL`. Also read `COHERE_RERANK_MODEL` env var to allow override.
- `rerank()`: if `_init_client()` returns False -> graceful degradation path (return documents in original order with synthetic scores `1.0 - i*0.01`, truncated to top_k)
- Normal path: call `self._client.rerank(model=self.MODEL, query=query, documents=documents, top_n=top_k)`, convert response.results to standard format using `r.index` and `r.relevance_score`
- ImportError for cohere package -> warning ("pip install cohere"), set `_available=False`
- Edge case guard: same as cross-encoder (skip if <= 1 document)

**__init__.py** -- Empty file (reranker modules import from `.base` directly, not from parent package, per Pitfall 5 in research).

Do NOT import from `lobster.core.vector` in any reranker module -- always import from `lobster.core.vector.rerankers.base` directly to avoid circular imports.
  </action>
  <verify>
```bash
cd /Users/tyo/Omics-OS/lobster
python -c "from lobster.core.vector.rerankers.base import BaseReranker, normalize_scores; print('BaseReranker OK')"
python -c "from lobster.core.vector.rerankers.cross_encoder_reranker import CrossEncoderReranker; print('CrossEncoder OK')"
python -c "from lobster.core.vector.rerankers.cohere_reranker import CohereReranker; print('Cohere OK')"
```
All three imports succeed without loading models (lazy loading).
  </verify>
  <done>
BaseReranker ABC defined with rerank() contract and normalize_scores() helper. CrossEncoderReranker and CohereReranker implementations exist with lazy loading and proper import guards. No models loaded at import time.
  </done>
</task>

<task type="auto">
  <name>Task 2: Config factory + service integration + __init__.py export</name>
  <files>
    lobster/core/vector/config.py
    lobster/core/vector/service.py
    lobster/core/vector/__init__.py
  </files>
  <action>
**config.py** -- Add reranker support to VectorSearchConfig:
- Add `from lobster.core.schemas.search import RerankerType` to existing imports (RerankerType is already in that module)
- Add field: `reranker: RerankerType = Field(default=RerankerType.none, description="Reranking strategy for search results")`
- Add `create_reranker()` method following the existing `create_backend()`/`create_embedder()` pattern:
  - `RerankerType.none` -> return `None`
  - `RerankerType.cross_encoder` -> lazy import `CrossEncoderReranker` from `lobster.core.vector.rerankers.cross_encoder_reranker`, return instance
  - `RerankerType.cohere` -> lazy import `CohereReranker` from `lobster.core.vector.rerankers.cohere_reranker`, return instance
  - Unknown -> raise ValueError with available options
- Update `from_env()`: read `LOBSTER_RERANKER` env var (default "none"), parse to `RerankerType`, pass to constructor. Use `try: RerankerType(reranker_str) except ValueError: RerankerType.none` to be safe.
- Add TYPE_CHECKING import for `BaseReranker` and type the return of `create_reranker()` as `BaseReranker | None`

**service.py** -- Wire reranking into match_ontology():
- Add `reranker` parameter to `__init__`: `reranker: BaseReranker | None = None` (with TYPE_CHECKING import for BaseReranker from `lobster.core.vector.rerankers.base`)
- Store as `self._reranker = reranker`
- Add `_get_reranker()` method following `_get_backend()`/`_get_embedder()` pattern:
  - If `self._reranker is not None`, return it
  - Otherwise, call `self._config.create_reranker()` which returns None for RerankerType.none
  - Cache result (set `self._reranker` -- but use a sentinel `_UNSET` to distinguish "not checked" from "checked and is None")
  - Use a `_reranker_resolved: bool = False` flag: if False, resolve via config, set flag True. If True, return cached value.
- In `match_ontology()`, after `raw_matches = self.query(term, collection, top_k=oversampled_k)`, add reranking step:
  ```
  reranker = self._get_reranker()
  if reranker is not None and len(raw_matches) > 1:
      documents = [m["term"] for m in raw_matches]
      reranked = reranker.rerank(term, documents, top_k=k)
      # Normalize scores to [0, 1]
      from lobster.core.vector.rerankers.base import normalize_scores
      reranked = normalize_scores(reranked)
      # Rebuild OntologyMatch list in reranked order
      results = []
      for entry in reranked:
          original = raw_matches[entry["corpus_id"]]
          results.append(
              _OntologyMatch(
                  term=original["term"],
                  ontology_id=original["ontology_id"],
                  score=entry["score"],
                  metadata=original["metadata"],
                  distance_metric=original["distance_metric"],
              )
          )
      return results[:k]
  ```
- Keep the existing no-reranker path EXACTLY as-is (the `return results[:k]` at the end)
- Do NOT add reranking to `query()` -- only `match_ontology()` per research recommendation

**__init__.py** -- Add BaseReranker to lazy exports:
- Add `"BaseReranker"` to `__all__` list
- Add TYPE_CHECKING import: `from lobster.core.vector.rerankers.base import BaseReranker`
- Add lazy resolution in `__getattr__`: `if name == "BaseReranker": from lobster.core.vector.rerankers.base import BaseReranker; return BaseReranker`

Run existing tests to verify no regressions: `pytest tests/unit/core/vector/ -v`
All existing tests must pass unchanged because the default reranker is "none" which preserves current behavior exactly.
  </action>
  <verify>
```bash
cd /Users/tyo/Omics-OS/lobster
# Verify no regressions
pytest tests/unit/core/vector/ -v

# Verify config reads env var
python -c "
from lobster.core.vector.config import VectorSearchConfig
from lobster.core.schemas.search import RerankerType
c = VectorSearchConfig()
assert c.reranker == RerankerType.none
assert c.create_reranker() is None
print('Config OK: default reranker is none, create_reranker returns None')
"

# Verify lazy export
python -c "from lobster.core.vector import BaseReranker; print('BaseReranker lazy export OK')"
```
  </verify>
  <done>
VectorSearchConfig has reranker field + create_reranker() factory. VectorSearchService.match_ontology() applies reranking between search and truncation when reranker is configured. Default reranker=none preserves all existing behavior. All prior tests pass unchanged.
  </done>
</task>

</tasks>

<verification>
1. All existing tests pass: `pytest tests/unit/core/vector/ -v` (no regressions from reranker=none default)
2. Reranker module imports work without loading models: `python -c "from lobster.core.vector.rerankers.base import BaseReranker"`
3. Config factory returns None for none, CrossEncoderReranker for cross_encoder, CohereReranker for cohere
4. Service constructor accepts optional reranker parameter for dependency injection (testing)
5. BaseReranker is accessible via `from lobster.core.vector import BaseReranker`
</verification>

<success_criteria>
- BaseReranker ABC exists with rerank() contract and normalize_scores() helper
- CrossEncoderReranker and CohereReranker implementations exist with lazy loading + import guards
- CohereReranker logs warning and returns original order when API key missing
- VectorSearchConfig has reranker field with from_env() reading LOBSTER_RERANKER
- VectorSearchService.match_ontology() applies reranking when configured
- Default reranker=none produces zero behavioral changes (all existing tests pass)
</success_criteria>

<output>
After completion, create `.planning/phases/04-performance/04-01-SUMMARY.md`
</output>
