---
phase: 06-metabolomics-package
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/lobster-metabolomics/pyproject.toml
  - packages/lobster-metabolomics/LICENSE
  - packages/lobster-metabolomics/README.md
  - packages/lobster-metabolomics/lobster/agents/metabolomics/config.py
  - packages/lobster-metabolomics/lobster/services/quality/metabolomics_quality_service.py
  - packages/lobster-metabolomics/lobster/services/quality/metabolomics_preprocessing_service.py
  - packages/lobster-metabolomics/lobster/services/analysis/metabolomics_analysis_service.py
  - packages/lobster-metabolomics/lobster/services/annotation/metabolomics_annotation_service.py
  - lobster/core/schemas/metabolomics.py
autonomous: true
requirements:
  - MET-01
  - MET-02
  - MET-03
  - MET-04
  - MET-05
  - MET-17

must_haves:
  truths:
    - "Package structure exists at packages/lobster-metabolomics/ with pyproject.toml, entry points stub, and PEP 420 namespace layout"
    - "MetabolomicsQualityService.assess_quality returns 3-tuple with RSD, TIC CV, QC sample metrics, and missing value analysis"
    - "MetabolomicsPreprocessingService has filter_features, impute_missing_values, normalize, and correct_batch_effects methods all returning 3-tuples"
    - "MetabolomicsAnalysisService has run_univariate_statistics, run_pca, run_pls_da, run_opls_da, and calculate_fold_changes methods all returning 3-tuples"
    - "MetabolomicsAnnotationService has annotate_by_mz and classify_lipids methods returning 3-tuples with MSI confidence levels"
    - "BUG-14 fixed: sparse matrix zero-checking uses nnz-based calculation instead of .data == 0"
  artifacts:
    - path: "packages/lobster-metabolomics/pyproject.toml"
      provides: "Package metadata, dependencies, entry points stub for metabolomics_expert"
      contains: "lobster.agents"
    - path: "packages/lobster-metabolomics/lobster/agents/metabolomics/config.py"
      provides: "MetabPlatformConfig with lc_ms, gc_ms, nmr platform configs + detect_platform_type"
      contains: "PLATFORM_CONFIGS"
    - path: "packages/lobster-metabolomics/lobster/services/quality/metabolomics_quality_service.py"
      provides: "MetabolomicsQualityService with assess_quality method"
      contains: "class MetabolomicsQualityService"
    - path: "packages/lobster-metabolomics/lobster/services/quality/metabolomics_preprocessing_service.py"
      provides: "MetabolomicsPreprocessingService with filter, impute, normalize, batch correct methods"
      contains: "class MetabolomicsPreprocessingService"
    - path: "packages/lobster-metabolomics/lobster/services/analysis/metabolomics_analysis_service.py"
      provides: "MetabolomicsAnalysisService with univariate, PCA, PLS-DA, OPLS-DA, fold change methods"
      contains: "class MetabolomicsAnalysisService"
    - path: "packages/lobster-metabolomics/lobster/services/annotation/metabolomics_annotation_service.py"
      provides: "MetabolomicsAnnotationService with m/z annotation and lipid class methods"
      contains: "class MetabolomicsAnnotationService"
    - path: "lobster/core/schemas/metabolomics.py"
      provides: "BUG-14 fix for sparse matrix zero-checking"
      contains: "adata.X.nnz"
  key_links:
    - from: "metabolomics_quality_service.py assess_quality"
      to: "AnalysisStep IR"
      via: "Returns 3-tuple (AnnData, Dict, AnalysisStep)"
      pattern: "return.*adata.*stats.*ir"
    - from: "metabolomics_preprocessing_service.py normalize"
      to: "AnalysisStep IR"
      via: "Returns 3-tuple with method-specific IR code_template"
      pattern: "return.*adata.*stats.*ir"
    - from: "metabolomics_analysis_service.py run_pls_da"
      to: "sklearn PLSRegression"
      via: "Uses PLSRegression with LabelBinarizer for class encoding + VIP scores"
      pattern: "PLSRegression"
    - from: "config.py PLATFORM_CONFIGS"
      to: "Service methods"
      via: "Platform-specific defaults passed to services from tools"
      pattern: "MetabPlatformConfig"
---

<objective>
Create the lobster-metabolomics package scaffold with all 4 stateless services (quality, preprocessing, analysis, annotation) plus MetabPlatformConfig. Also fix BUG-14 in core metabolomics schema.

Purpose: Establishes the service-layer foundation that Plan 02 tools will wrap. Every service method follows the 3-tuple pattern (AnnData, Dict, AnalysisStep). The package structure mirrors lobster-proteomics exactly.
Output: Complete package directory with pyproject.toml, 4 service files, config.py, BUG-14 fix
</objective>

<execution_context>
@/Users/tyo/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tyo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-metabolomics-package/06-RESEARCH.md

# Reference: proteomics package structure (follow this pattern exactly)
@packages/lobster-proteomics/pyproject.toml
@packages/lobster-proteomics/lobster/agents/proteomics/config.py
@packages/lobster-proteomics/lobster/services/quality/proteomics_quality_service.py
@packages/lobster-proteomics/lobster/services/quality/proteomics_preprocessing_service.py

# BUG-14 location
@lobster/core/schemas/metabolomics.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Package scaffold + PlatformConfig + BUG-14 fix</name>
  <files>
    packages/lobster-metabolomics/pyproject.toml
    packages/lobster-metabolomics/LICENSE
    packages/lobster-metabolomics/README.md
    packages/lobster-metabolomics/lobster/agents/metabolomics/config.py
    packages/lobster-metabolomics/lobster/agents/metabolomics/py.typed
    lobster/core/schemas/metabolomics.py
  </files>
  <action>
Create the package directory structure following lobster-proteomics exactly. PEP 420 namespace: NO `lobster/__init__.py`, NO `lobster/agents/__init__.py`, NO `lobster/services/__init__.py`. Only `lobster/agents/metabolomics/__init__.py` gets created (in Plan 02 when the agent exists).

1. **pyproject.toml**: Model on lobster-proteomics/pyproject.toml.
   - name: "lobster-metabolomics"
   - version: "1.0.0"
   - description: "Metabolomics agent for Lobster AI (LC-MS, GC-MS, NMR untargeted metabolomics)"
   - license: "AGPL-3.0-or-later"
   - requires-python: ">=3.12,<3.14"
   - dependencies: lobster-ai~=1.0.0, anndata>=0.9.0, numpy>=1.23.0, pandas>=1.5.0, scipy>=1.10.0, scikit-learn>=1.3.0, statsmodels>=0.14.0 (NO lifelines, NO networkx - not needed for metabolomics)
   - Entry points stub: `[project.entry-points."lobster.agents"]` with `metabolomics_expert = "lobster.agents.metabolomics.metabolomics_expert:AGENT_CONFIG"`
   - Entry points stub: `[project.entry-points."lobster.states"]` with `MetabolomicsExpertState = "lobster.agents.metabolomics.state:MetabolomicsExpertState"`
   - `[tool.setuptools]` packages.find with where=["."], include=["lobster*"], namespaces=true
   - `[tool.setuptools.package-data]` "*" = ["py.typed"]

2. **LICENSE**: Copy AGPL-3.0-or-later text (same as lobster-proteomics/LICENSE).

3. **README.md**: Brief package description (follow proteomics README pattern).

4. **config.py**: Create `MetabPlatformConfig` dataclass with fields:
   - platform_type (str): "lc_ms", "gc_ms", or "nmr"
   - display_name, description (str)
   - expected_missing_rate_range (tuple), max_missing_per_sample (float), max_missing_per_feature (float)
   - max_rsd_qc_samples (float), min_features_per_sample (int)
   - default_normalization (str), log_transform (bool), default_imputation (str)
   - default_fold_change_threshold (float), default_n_pca_components (int)
   - get_qc_defaults() and get_normalization_defaults() helper methods

   Create PLATFORM_CONFIGS dict with 3 entries using exact values from research:
   - lc_ms: missing=(0.20,0.60), max_missing_sample=0.60, max_missing_feature=0.80, max_rsd_qc=30.0, min_features=50, default_norm="pqn", log=True, default_impute="knn", fc=1.5, pca=10
   - gc_ms: missing=(0.10,0.40), max_missing_sample=0.40, max_missing_feature=0.60, max_rsd_qc=25.0, min_features=30, default_norm="tic", log=True, default_impute="min", fc=2.0, pca=10
   - nmr: missing=(0.0,0.10), max_missing_sample=0.10, max_missing_feature=0.20, max_rsd_qc=20.0, min_features=100, default_norm="pqn", log=False, default_impute="median", fc=1.5, pca=10

   Create detect_platform_type(adata, force_type=None) -> str function:
   - If force_type provided, validate against PLATFORM_CONFIGS and return
   - Detection scoring: check var columns for LC-MS hints (retention_time, mz, adduct), GC-MS hints (ri, retention_index), NMR hints (ppm, chemical_shift)
   - Check uns for platform hints
   - Check missing rate (high -> lc_ms, low -> nmr, medium -> gc_ms)
   - Return highest-scoring platform or "lc_ms" as default

   Create get_platform_config(platform_type) -> MetabPlatformConfig helper.

5. **py.typed**: Empty PEP 561 marker file in agents/metabolomics/.

6. **BUG-14 fix** in lobster/core/schemas/metabolomics.py:
   - In `_validate_intensity_data()` (around line 466): Replace `(adata.X.data == 0).sum() / adata.X.data.size * 100` with correct sparse calculation: `total = adata.X.shape[0] * adata.X.shape[1]`, `stored_zeros = (adata.X.data == 0).sum() if hasattr(adata.X, 'data') and adata.X.data.size > 0 else 0`, `actual_nonzero = adata.X.nnz - stored_zeros`, `zero_pct = (total - actual_nonzero) / total * 100`. Use `hasattr(adata.X, "toarray")` as the sparse check (not `hasattr(adata.X, "data")`).
   - In `_validate_missing_values()` (around line 493): Same fix. For sparse matrices, convert to dense in chunks or use the total-minus-nnz approach for zero counting. For true missing value detection in sparse, note that NaN becomes 0 in sparse format, so track with: `if hasattr(adata.X, "toarray"): X_dense = adata.X.toarray(); missing_pct = np.isnan(X_dense).sum() / X_dense.size * 100` (small datasets) or for large: warn that sparse metabolomics data may lose NaN distinction.
  </action>
  <verify>
    - `ls packages/lobster-metabolomics/pyproject.toml` exists
    - `ls packages/lobster-metabolomics/lobster/agents/metabolomics/config.py` exists
    - `python -c "from lobster.core.schemas.metabolomics import _validate_intensity_data; print('BUG-14 fix imports OK')"` (verify the fixed function can be imported)
    - Verify NO `packages/lobster-metabolomics/lobster/__init__.py` exists (PEP 420)
    - `grep -c "toarray" lobster/core/schemas/metabolomics.py` shows the new sparse check pattern
  </verify>
  <done>Package scaffold exists with pyproject.toml (entry points, deps), MetabPlatformConfig with 3 platform configs (lc_ms, gc_ms, nmr), detect_platform_type function, BUG-14 fixed with correct sparse matrix handling in both _validate_intensity_data and _validate_missing_values</done>
</task>

<task type="auto">
  <name>Task 2: Four stateless services (quality, preprocessing, analysis, annotation)</name>
  <files>
    packages/lobster-metabolomics/lobster/services/quality/metabolomics_quality_service.py
    packages/lobster-metabolomics/lobster/services/quality/metabolomics_preprocessing_service.py
    packages/lobster-metabolomics/lobster/services/analysis/metabolomics_analysis_service.py
    packages/lobster-metabolomics/lobster/services/annotation/metabolomics_annotation_service.py
  </files>
  <action>
Create all 4 services. Every method MUST return `Tuple[AnnData, Dict[str, Any], AnalysisStep]`. Every method MUST create AnalysisStep IR with code_template, imports, parameters, and parameter_schema. Follow ProteomicsQualityService/ProteomicsPreprocessingService as the reference pattern for IR creation.

**Service 1: MetabolomicsQualityService** (`services/quality/metabolomics_quality_service.py`)

Class with one public method:
- `assess_quality(adata, qc_label="QC", rsd_threshold=30.0)` -> 3-tuple
  - Copy adata, convert sparse to dense if needed (`adata.X.toarray()` check)
  - Per-feature RSD: `(nanstd / nanmean) * 100`, store in var['rsd']
  - Per-sample TIC: `nansum(X, axis=1)`, compute TIC CV
  - Missing value analysis: `np.isnan(X).sum() / X.size * 100`
  - QC sample evaluation: if 'sample_type' column exists and has qc_label matches, compute QC-specific RSD
  - Per-sample missing rate, per-feature missing rate stored in obs/var
  - Stats dict: n_samples, n_features, median_rsd, high_rsd_features, missing_pct, tic_cv, qc_stats
  - IR: operation="metabolomics_qc.assess_quality", library="numpy/scipy"

**Service 2: MetabolomicsPreprocessingService** (`services/quality/metabolomics_preprocessing_service.py`)

Class with 4 public methods:

- `filter_features(adata, min_prevalence=0.5, max_rsd=None, blank_ratio_threshold=None, blank_label="blank")` -> 3-tuple
  - Filter by prevalence: keep features present in >= min_prevalence fraction of samples (non-NaN count / n_samples)
  - Filter by RSD: if max_rsd provided, keep features with RSD <= max_rsd (requires var['rsd'])
  - Filter by blank ratio: if blank_ratio_threshold and blank samples exist, compute mean(blank) / mean(sample) per feature, remove features with ratio > threshold
  - Stats: n_before, n_after, n_removed_prevalence, n_removed_rsd, n_removed_blank

- `impute_missing_values(adata, method="knn", knn_neighbors=5)` -> 3-tuple
  - Methods: "knn" (sklearn.impute.KNNImputer), "min" (per-feature minimum / 2), "lod_half" (LOD/2 if LOD in var else min/5), "median" (per-feature nanmedian), "mice" (IterativeImputer from sklearn)
  - Always work on dense copy. Replace NaN with imputed values.
  - Stats: method_used, n_values_imputed, pct_imputed, imputation_details

- `normalize(adata, method="pqn", log_transform=True, reference_sample=None)` -> 3-tuple
  - Methods:
    - "pqn": Probabilistic Quotient Normalization (see research pattern). Reference = median spectrum. Quotient = sample / reference. Factor = nanmedian of quotients. Warn if < 20 non-NaN features for quotient.
    - "tic": Total Ion Current. Factor = nansum per sample, scale to median TIC.
    - "is": Internal Standard. Requires reference_sample (list of IS feature indices/names). Factor = nanmedian of IS features per sample.
    - "median": Median normalization. Factor = nanmedian per sample, scale to global median.
    - "quantile": Quantile normalization via ranking.
  - If log_transform=True, apply np.log2 after normalization. Handle zeros: add small offset (half of minimum positive value) before log.
  - Store normalization factors in obs['norm_factor']. Store method in uns['normalization_method'].
  - Stats: method, log_transformed, median_norm_factor, normalization_range

- `correct_batch_effects(adata, batch_key, method="combat", qc_label="QC")` -> 3-tuple
  - Methods:
    - "combat": Parametric empirical Bayes batch correction. Use scanpy's `sc.pp.combat` if available (it is in lobster-ai deps), otherwise implement manually following proteomics pattern.
    - "median_centering": Per-batch median centering. Compute global median per feature, subtract batch median, add global median.
    - "qc_rlsc": QC-based signal correction. Requires QC samples labeled with qc_label. For each feature, fit smoothing spline (scipy UnivariateSpline or statsmodels lowess) through QC sample injection order, correct all samples by interpolated QC trend. Fall back to median_centering if < 5 QC samples per batch, with warning.
  - Stats: method, n_batches, batch_sizes, correction_summary

**Service 3: MetabolomicsAnalysisService** (`services/analysis/metabolomics_analysis_service.py`)

Class with 5 public methods:

- `run_univariate_statistics(adata, group_column, method="auto", fdr_method="fdr_bh")` -> 3-tuple
  - Auto-detect: 2 groups -> t-test/Wilcoxon, 3+ groups -> ANOVA/Kruskal-Wallis
  - method="auto": use Shapiro-Wilk on small samples or default to non-parametric (Wilcoxon/Kruskal) for metabolomics
  - method="ttest": scipy.stats.ttest_ind
  - method="wilcoxon": scipy.stats.mannwhitneyu (note: mannwhitneyu for independent samples, not signed-rank)
  - method="anova": scipy.stats.f_oneway
  - method="kruskal": scipy.stats.kruskal
  - Apply FDR correction via statsmodels.stats.multitest.multipletests
  - Store results in var: p_value, fdr, test_statistic, significant (fdr < 0.05)
  - Stats: n_tested, n_significant_raw, n_significant_fdr, method_used, groups

- `run_pca(adata, n_components=10)` -> 3-tuple
  - sklearn.decomposition.PCA on imputed (non-NaN) data. Scale with StandardScaler first.
  - Store scores in obsm['X_pca'], loadings in varm['PCs'], variance_ratio in uns['pca_variance_ratio']
  - Stats: n_components, variance_explained (per component), total_variance_explained

- `run_pls_da(adata, group_column, n_components=2, permutation_test=True, n_permutations=100)` -> 3-tuple
  - Follow research pattern exactly: PLSRegression with LabelBinarizer encoding
  - Binary case: expand Y to 2 columns with np.hstack([1-Y, Y])
  - Compute VIP scores using standard formula. Validate: mean(VIP^2) should approx equal 1.0
  - Store: scores in obsm['X_plsda'], VIP in var['vip_score'], Q2/R2 in uns
  - If permutation_test: shuffle Y labels, refit PLS n_permutations times, compute p-value as fraction where permuted R2 >= observed R2
  - Stats: n_components, r2, q2 (from cross-validation), vip_gt_1_count, permutation_p_value (if tested)

- `run_opls_da(adata, group_column, n_orthogonal=1, n_predictive=1, permutation_test=True, n_permutations=100)` -> 3-tuple
  - Follow research NIPALS pattern exactly. Custom implementation ~100 lines.
  - Encode Y with LabelBinarizer, center/scale with StandardScaler
  - Extract orthogonal components: PLS weight, predictive score/loading, orthogonal weight/score/loading, remove orthogonal variation
  - Final PLS on filtered X
  - Store: predictive_scores in obsm['X_oplsda_pred'], orthogonal_scores in obsm['X_oplsda_orth']
  - Cross-validation for Q2: 7-fold CV, compute PRESS, derive Q2
  - If permutation_test: shuffle Y, refit, compute permutation p-value
  - Warn if Q2 < 0.5 or R2 >> Q2 (overfitting signal)
  - Stats: r2, q2, n_orthogonal, n_predictive, permutation_p_value

- `calculate_fold_changes(adata, group_column, reference_group=None, log_space=True)` -> 3-tuple
  - If log_space (data already log-transformed): FC = mean(group) - mean(ref) (difference in log = log ratio)
  - If not log_space: FC = mean(group) / mean(ref), then log2 transform
  - Auto-select reference: if reference_group not specified, use first group alphabetically
  - Store in var: log2_fold_change, mean_group, mean_reference
  - Stats: reference, comparison, n_upregulated (FC > 1), n_downregulated (FC < -1)

**Service 4: MetabolomicsAnnotationService** (`services/annotation/metabolomics_annotation_service.py`)

Class with a bundled reference database and 2 public methods:

- At class level or module level, define METABOLITE_REFERENCE_DB: a dict of ~50-100 common metabolites for v1 (NOT full HMDB). Structure: {name: {"monoisotopic_mass": float, "formula": str, "kegg_id": str, "hmdb_id": str, "class": str}}. Include common metabolites: amino acids (20), organic acids (citric, lactic, pyruvic, etc.), sugars (glucose, fructose, etc.), nucleotides, fatty acids, lipid classes (PC, PE, SM, TG, etc.). Also define COMMON_ADDUCTS dict: {"[M+H]+": 1.007276, "[M+Na]+": 22.989218, "[M+K]+": 38.963158, "[M-H]-": -1.007276, "[M+Cl]-": 34.969402, "[M+FA-H]-": 44.998201, "[M-H2O+H]+": -17.002740}.

- `annotate_by_mz(adata, mz_column="mz", ppm_tolerance=10.0, adducts=None, ion_mode="positive")` -> 3-tuple
  - Read m/z values from var[mz_column]
  - For each m/z, compute candidate masses for each adduct: neutral_mass = mz - adduct_mass (for positive) or mz + abs(adduct_mass) (for negative)
  - Match neutral mass against METABOLITE_REFERENCE_DB within ppm_tolerance: ppm = abs(observed - theoretical) / theoretical * 1e6
  - Assign MSI level 2 for m/z-only matches (putative annotation)
  - Store annotations in var: annotation_name, annotation_hmdb, annotation_kegg, annotation_class, annotation_msi_level, annotation_ppm_error, annotation_adduct
  - For multiple matches per feature, keep best (lowest ppm error)
  - Stats: n_annotated, n_unannotated, annotation_rate_pct, msi_level_distribution

- `classify_lipids(adata, annotation_column="annotation_class")` -> 3-tuple
  - Group features by lipid class from annotation results (or from m/z ranges if no annotation)
  - For annotated data: group by annotation_class column, compute per-class statistics (n_features, mean_intensity, total_intensity)
  - For unannotated data: use m/z ranges for rough lipid class estimation (MSI level 3). Ranges: FA (200-400), lysophospholipids (400-600), phospholipids (600-900), sphingolipids (500-850), glycerolipids/TG (800-1000)
  - Store class assignments in var['lipid_class']
  - Stats: n_classes, class_counts, class_intensity_summary, msi_level (3 if from m/z ranges)
  </action>
  <verify>
    - `python -c "from lobster.services.quality.metabolomics_quality_service import MetabolomicsQualityService; print('QualityService OK')"` from the package directory (after editable install)
    - `python -c "from lobster.services.quality.metabolomics_preprocessing_service import MetabolomicsPreprocessingService; print('PreprocessingService OK')"`
    - `python -c "from lobster.services.analysis.metabolomics_analysis_service import MetabolomicsAnalysisService; print('AnalysisService OK')"`
    - `python -c "from lobster.services.annotation.metabolomics_annotation_service import MetabolomicsAnnotationService; print('AnnotationService OK')"`
    - Verify each service class can be instantiated: `MetabolomicsQualityService()` does not raise
    - Spot-check: verify `MetabolomicsAnalysisService` imports PLSRegression from sklearn
  </verify>
  <done>All 4 services exist with correct 3-tuple return signatures. MetabolomicsQualityService has assess_quality. MetabolomicsPreprocessingService has filter_features, impute_missing_values, normalize, correct_batch_effects. MetabolomicsAnalysisService has run_univariate_statistics, run_pca, run_pls_da, run_opls_da, calculate_fold_changes. MetabolomicsAnnotationService has annotate_by_mz and classify_lipids with bundled metabolite reference DB.</done>
</task>

</tasks>

<verification>
- Package scaffold at packages/lobster-metabolomics/ with correct PEP 420 layout (no lobster/__init__.py)
- pyproject.toml has entry points for metabolomics_expert agent
- 4 service files all importable and instantiable
- BUG-14 fixed: `grep "toarray" lobster/core/schemas/metabolomics.py` shows new sparse check
- All service methods return 3-tuples with AnalysisStep IR
</verification>

<success_criteria>
1. `packages/lobster-metabolomics/` directory exists with pyproject.toml, LICENSE, README.md
2. MetabPlatformConfig in config.py with 3 platform configs (lc_ms, gc_ms, nmr)
3. 4 service files importable with all methods specified
4. BUG-14 fixed in lobster/core/schemas/metabolomics.py
5. No `lobster/__init__.py` anywhere in the package (PEP 420)
</success_criteria>

<output>
After completion, create `.planning/phases/06-metabolomics-package/06-01-SUMMARY.md`
</output>
